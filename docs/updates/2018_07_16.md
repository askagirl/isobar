# Update for July 16, 2018

It's been a while since the last update, and I apologize for that. Our strategic direction has felt less clear to me over the past few weeks, and that lack of clarity combined with some difficulty in my personal life overcame my motivation to post for a while. I just wanted to turn inward and write code in relative isolation. Things are clearer and I'm feeling better, and I'd like to resume posting updates on a weekly basic and ask your forgiveness for the gap in communication.

## The emergence of Ocean

When we demonstrate Isobar for Siberian Media Holding leadership in June, there was definitely interest in Isobar's potential as a high-performance collaborative text editor that runs on the desktop or in the browser, but there was way *more* excitement about CRDTs and their potential to impact version control. At first, this feedback caused some cognitive dissonance for me. After working so hard on Isobar, it wasn't easy to hear that what I consider to be an implementation detail was the most exciting aspect of what we had built. But the more I thought about it, the more intrigued I became with the application of CRDTs to version control. The idea had been floating around in my mind since early in the development of Teletype, but now I felt encouraged to take the idea more seriously.

After a bit of indecision, we decided to dive in. We've now shifted our focus to a new project called Ocean, which enables real-time, fine-grained version control. Long term, we see Ocean and Isobar as two components of the same overall porject. Ocean will be an editor-agnostic datastore for fine-grained edit history that enables real-time synchronization. I will be like Git, but it will persist and synchronize changes at the granularity of individual keystrokes. We envision Isobar and Ocean's native user itnerface and the best showcase of its capabilities. One example is the idea of "layers", which are like commits that can be freely edited at any time.

Git never would have taken off if it had been trapped inside a particular editor, and so if we really want to maximize the utility of what we're building, it makes sense to be editor-agnostic at the core. That's why we've decided to focus on delivering Ocean as a standalone project. It may look like we have stopped working on Isobar, but since Isobar will ultimately build on top of Ocean, the spirit of the overall project continues.

We pulled out Ocean into its own repository a couple weeks ago, but I'm staring to wonder if that was a good idea. Naming and organization are hard, so we may reverse this decision. Stay tuned.

## Progress on Ocean

Previously, Isobar's allowed you to invite guests into your workspace, but it was a centralized design. The workspace host owned all the files and serialized all guest requests to manipulate the file system. If the host dropped offline, the collaboration was over. With Ocean, we're shooting for full decentralization. Multiple people can maintain a first-class replica of a given repository, just like Git.

To achieve that, over the past few weeks, we've been working on replicating the contents of the file system in addition the individual buffers. That means that if one person moves a directory while a collaborator adds a file inside of it, both parties will eventually converge to the same view of the world. It's proven to be a surprisingly complex problem.

We maintain a CRDT that represents the state of all the files and directories within the repository, but the only cross-platform way to detect changes is to scan the underlying file system and compare it to the contents of our in-memory representation. We can sometimes use inodes to detect moves, but not always, and the file system could change at any time, including during a scan. Once we've determined what changes have been performed locally, we need to relay them to remote collaborators in such a way that concurrent changes don't interfere with convergence.

We're a few weeks in and still not done, but after spinning our wheels quite a bit we feel like we've found a design that is going to work. To represent the state of all the files and directories in the repository, we've taken insipiration from Linux's Btrfs file system. We use the same B-tree that we use to represent individual text buffers, but instead of populating it with fragments of inserted text, we store a heterogenous mix of items.
