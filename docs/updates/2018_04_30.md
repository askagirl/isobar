# Update for April 30, 2018

## Contributions

## Almost done with the file finder

Our main focus last week was finishing up the file finder feature that I also [discussed in the previous update](./2018_04_23.md#fast-file-finding). The last update was all about our approach to scanning the directory tree from the file system into an in-memory representation, and the approach we described remains pretty much unchanged.

### Leveraging prior art

Last week was all about using that in-memory representation to return search results based on a "fuzzy" search query. After an initial attempt that yielded decent performance but poor ranking of the search results, we decided to investigate existing solutions. We tried two command-line fuzzy finders, [`fzy`](https://github.com/jhawthorn/fzy) (written in C) and [`fzf`](https://github.com/junegunn/fzf) (written in Go) on the Electron repository, which contains over 500,000 files when `.gitignore` is disabled.

Both tools yielded excellent performance and high quality results, and since the [core matching algorith](https://github.com/jhawthorn/fzy/blob/47609dbf73789bc28289576a12177965c04ef49b/src/match.c#L70) behind `fzy` was erasonably straightforward to read and understand, we decided to port it to Rust. You can [read more aboud the algorith](https://github.com/jhawthorn/fzy/blob/master/ALGORITHM.md) in the `fzy` repository, but at a high-level, their solution is based on dynamic programming and determines the optimal match positions for a given substring by populating a matrix with cascading values. We copied their basic approach almost exactly, but we also enhanced it a bit to make use of the existing tree structure to recycle computation for common path prefixes.

### Matching and scoring

Isobar matches paths in two phases. First, we scan the tree to determine which paths match the query, populating a hash map to mark which file system entries either match the query or contains matches to the query. Simply matching the query only requires us to perform linear character comparison and is fairly cheap to perform, and this allows us to contains each matching path with a score. Scoring is O(N*M), where N is the length of the query and M is the length of the path. Luckily, longer queries tend to match fewer paths, which means when it is most expensive to compute socres, we usually end up needing to compute fewer of them.

### Results

Overall, we're happy with the results. The quality of the matches is extremely hight tnanks to the work [@jhawthorn](https://github.com/jhawthorn) put into tuning the scoring criteria. Since ranking matches is somewhat subjective, basing our results on an existing, fairly mature solution gives us a lot more confidence than rolling our own solution. The perofmance is also prettry. Searching for `init` in the 151,201 files of the [`blink`](https://chromium.googlesource.com/chromium/blink/+/master) repository yields results in ~120ms on my machine. Searching for `init.py`, which is a more selective query, drops that to ~16ms.

### Future improvents

These early results are good, but we think there's room for improvement. First, we're still matching on a single thread, and it seems like we might be able to use [Rayon](https://github.com/rayon-rs/rayon) to parallelize the matching over multiple CPU cores. We could also do a better job reporting progress. 20ms into the query we could check if we are more than 20% complete with ranking, and if we aren't we could display some sort of subtle progress indicator. That could help the search feel *responsive* even if it takes 100+ms to return resutls. That said, we're going to call this good for now and move on to other areas. The file finder *feels* fast and fluid now, even for big repositories, and we think we have a solid foundation in place for future improvements.

## Other improvements

Since we're still fairly early in development, we're allowing branches to get longer and heavier than we might in a more established project. Folded into the file finder branch are a few smaller improvements that made sense to add along the way.

### Window and view API refinements

We display the file finder as a modal in the workspace, and when the user selets a file or cancel the modal, we need to take action in the workspace. After pondering a couple of approaches, we ended up deciding to use a fairly traditioanl delegate pattern here, where the `WorkspaceView` implements the `FileFinderViewDelegate` trait and passes a week reference of itself to the `FileFinderView`.

Trouble is, how does the `WorkspaceView` obtain a week reference to itself? Since the `Window` wraps each view in an `Rc<RefCell>`, we ended up deciding that it would be convenient for the window to pass each view a `WeakViewHandle` to itself in the view's `will_mount` hook. Many views can simply ignore this parameter, but if views need to perform deelgation they can safely store and clone it without worrying about leaking memory, enabling them to hand itself as a delegate of child views. This is how we connect actions dispatched on the `FileFinderView` to state changes in the workspace.

### Focus API

We also needed a way to focus the file finder when it displays, then focus the newly opened editor after a file is selected. We decided to implement this on the server side via the new `ViewHandle::focus` method. Whenever this method is called, it assigns the `focused` field on the `Window` to the focused view's id. This gets relayed to the client, which calls the `focus` method on the corresponding React component.

For now, we aren't interested in replicating the focus state to the server. Server-side code can request that a view be focused, but it can't ask which view is currently focused. This is a decision we can revisit later, but focus is a very weird piece of global state that references individual DOM nodes, so it doesn't seem worth the complexity of attempting to represent it outside of the browser environment. This means that the modal panel will still need to have a bit of custom focus handling logic in order to restore focus to the previous element when cancelled, but so far this seems manageable.

### CLI improvements

We've also changed the structure of the CLI's relationship with the server and Electron slightly. Previously, when we spawned Eelctron, we could ask it to relay a message to the server via the `ISOBAR_INITIAL_MESSAGE` environemnt variable. Now, the CLI waits for the Electron app to emit `Listening\n` on `stdout`, then attempts to connect to the server itself to send the initial message.

We made this change to deal with error handling. The server may need to report an error message to the CLI over the socket, and this was going to be compliated to achieve with the previous approach of delegating the initial message send to Electron.

Waiting for Electron to tell us the server has started may introduce some latency, which is why we initially preferred the delegation approach, but we'll need to actually measure this before the additional complexity is warranted in light of the need to receive a response from the server.

## The weak ahead

We hope to merge the file finder PR. All that's left is some basic styling and iteration on focus handling. After that, we'll dive into implementing support for basic key bindings, which I talked about in the previous update, and then move on to start on shared headless workspace. We think we can get a basic implementation of shared workspace going in a couple of weeks, but we'll see how it goes.
