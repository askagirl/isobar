// automatically generated by the FlatBuffers compiler, do not modify


#![allow(dead_code)]
#![allow(unused_imports)]
extern crate flatbuffers;

// struct ReplicaId, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct ReplicaId {
  first_8_bytes_: u64,
  last_8_bytes_: u64,
} // pub struct ReplicaId
impl flatbuffers::SafeSliceAccess for ReplicaId {}
impl<'a> flatbuffers::Follow<'a> for ReplicaId {
  type Inner = &'a ReplicaId;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a ReplicaId>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a ReplicaId {
  type Inner = &'a ReplicaId;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<ReplicaId>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for ReplicaId {
    type Output = ReplicaId;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const ReplicaId as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b ReplicaId {
    type Output = ReplicaId;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const ReplicaId as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl ReplicaId {
  pub fn new<'a>(_first_8_bytes: u64, _last_8_bytes: u64) -> Self {
    ReplicaId {
      first_8_bytes_: _first_8_bytes.to_little_endian(),
      last_8_bytes_: _last_8_bytes.to_little_endian(),

    }
  }
  pub fn first_8_bytes<'a>(&'a self) -> u64 {
    self.first_8_bytes_.from_little_endian()
  }
  pub fn last_8_bytes<'a>(&'a self) -> u64 {
    self.last_8_bytes_.from_little_endian()
  }
}

// struct Timestamp, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Timestamp {
  value_: u64,
  replica_id_: ReplicaId,
} // pub struct Timestamp
impl flatbuffers::SafeSliceAccess for Timestamp {}
impl<'a> flatbuffers::Follow<'a> for Timestamp {
  type Inner = &'a Timestamp;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Timestamp>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Timestamp {
  type Inner = &'a Timestamp;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Timestamp>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Timestamp {
    type Output = Timestamp;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Timestamp as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Timestamp {
    type Output = Timestamp;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Timestamp as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Timestamp {
  pub fn new<'a>(_value: u64, _replica_id: &'a ReplicaId) -> Self {
    Timestamp {
      value_: _value.to_little_endian(),
      replica_id_: *_replica_id,

    }
  }
  pub fn value<'a>(&'a self) -> u64 {
    self.value_.from_little_endian()
  }
  pub fn replica_id<'a>(&'a self) -> &'a ReplicaId {
    &self.replica_id_
  }
}

pub enum GlobalTimestampOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GlobalTimestamp<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GlobalTimestamp<'a> {
    type Inner = GlobalTimestamp<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GlobalTimestamp<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GlobalTimestamp {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GlobalTimestampArgs<'args>) -> flatbuffers::WIPOffset<GlobalTimestamp<'bldr>> {
      let mut builder = GlobalTimestampBuilder::new(_fbb);
      if let Some(x) = args.timestamps { builder.add_timestamps(x); }
      builder.finish()
    }

    pub const VT_TIMESTAMPS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn timestamps(&self) -> Option<&'a [Timestamp]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Timestamp>>>(GlobalTimestamp::VT_TIMESTAMPS, None).map(|v| v.safe_slice() )
  }
}

pub struct GlobalTimestampArgs<'a> {
    pub timestamps: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , Timestamp>>>,
}
impl<'a> Default for GlobalTimestampArgs<'a> {
    #[inline]
    fn default() -> Self {
        GlobalTimestampArgs {
            timestamps: None,
        }
    }
}
pub struct GlobalTimestampBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GlobalTimestampBuilder<'a, 'b> {
  #[inline]
  pub fn add_timestamps(&mut self, timestamps: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Timestamp>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GlobalTimestamp::VT_TIMESTAMPS, timestamps);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GlobalTimestampBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GlobalTimestampBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GlobalTimestamp<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub mod buffer {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

pub enum OperationOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Operation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Operation<'a> {
    type Inner = Operation<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Operation<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Operation {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OperationArgs<'args>) -> flatbuffers::WIPOffset<Operation<'bldr>> {
      let mut builder = OperationBuilder::new(_fbb);
      builder.add_end_offset(args.end_offset);
      builder.add_start_offset(args.start_offset);
      if let Some(x) = args.lamport_timestamp { builder.add_lamport_timestamp(x); }
      if let Some(x) = args.local_timestamp { builder.add_local_timestamp(x); }
      if let Some(x) = args.new_text { builder.add_new_text(x); }
      if let Some(x) = args.version_in_range { builder.add_version_in_range(x); }
      if let Some(x) = args.end_id { builder.add_end_id(x); }
      if let Some(x) = args.start_id { builder.add_start_id(x); }
      builder.finish()
    }

    pub const VT_START_ID: flatbuffers::VOffsetT = 4;
    pub const VT_START_OFFSET: flatbuffers::VOffsetT = 6;
    pub const VT_END_ID: flatbuffers::VOffsetT = 8;
    pub const VT_END_OFFSET: flatbuffers::VOffsetT = 10;
    pub const VT_VERSION_IN_RANGE: flatbuffers::VOffsetT = 12;
    pub const VT_NEW_TEXT: flatbuffers::VOffsetT = 14;
    pub const VT_LOCAL_TIMESTAMP: flatbuffers::VOffsetT = 16;
    pub const VT_LAMPORT_TIMESTAMP: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn start_id(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(Operation::VT_START_ID, None)
  }
  #[inline]
  pub fn start_offset(&self) -> u64 {
    self._tab.get::<u64>(Operation::VT_START_OFFSET, Some(0)).unwrap()
  }
  #[inline]
  pub fn end_id(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(Operation::VT_END_ID, None)
  }
  #[inline]
  pub fn end_offset(&self) -> u64 {
    self._tab.get::<u64>(Operation::VT_END_OFFSET, Some(0)).unwrap()
  }
  #[inline]
  pub fn version_in_range(&self) -> Option<super::GlobalTimestamp<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<super::GlobalTimestamp<'a>>>(Operation::VT_VERSION_IN_RANGE, None)
  }
  #[inline]
  pub fn new_text(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operation::VT_NEW_TEXT, None)
  }
  #[inline]
  pub fn local_timestamp(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(Operation::VT_LOCAL_TIMESTAMP, None)
  }
  #[inline]
  pub fn lamport_timestamp(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(Operation::VT_LAMPORT_TIMESTAMP, None)
  }
}

pub struct OperationArgs<'a> {
    pub start_id: Option<&'a  super::Timestamp>,
    pub start_offset: u64,
    pub end_id: Option<&'a  super::Timestamp>,
    pub end_offset: u64,
    pub version_in_range: Option<flatbuffers::WIPOffset<super::GlobalTimestamp<'a >>>,
    pub new_text: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub local_timestamp: Option<&'a  super::Timestamp>,
    pub lamport_timestamp: Option<&'a  super::Timestamp>,
}
impl<'a> Default for OperationArgs<'a> {
    #[inline]
    fn default() -> Self {
        OperationArgs {
            start_id: None,
            start_offset: 0,
            end_id: None,
            end_offset: 0,
            version_in_range: None,
            new_text: None,
            local_timestamp: None,
            lamport_timestamp: None,
        }
    }
}
pub struct OperationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OperationBuilder<'a, 'b> {
  #[inline]
  pub fn add_start_id(&mut self, start_id: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(Operation::VT_START_ID, start_id);
  }
  #[inline]
  pub fn add_start_offset(&mut self, start_offset: u64) {
    self.fbb_.push_slot::<u64>(Operation::VT_START_OFFSET, start_offset, 0);
  }
  #[inline]
  pub fn add_end_id(&mut self, end_id: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(Operation::VT_END_ID, end_id);
  }
  #[inline]
  pub fn add_end_offset(&mut self, end_offset: u64) {
    self.fbb_.push_slot::<u64>(Operation::VT_END_OFFSET, end_offset, 0);
  }
  #[inline]
  pub fn add_version_in_range(&mut self, version_in_range: flatbuffers::WIPOffset<super::GlobalTimestamp<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::GlobalTimestamp>>(Operation::VT_VERSION_IN_RANGE, version_in_range);
  }
  #[inline]
  pub fn add_new_text(&mut self, new_text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operation::VT_NEW_TEXT, new_text);
  }
  #[inline]
  pub fn add_local_timestamp(&mut self, local_timestamp: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(Operation::VT_LOCAL_TIMESTAMP, local_timestamp);
  }
  #[inline]
  pub fn add_lamport_timestamp(&mut self, lamport_timestamp: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(Operation::VT_LAMPORT_TIMESTAMP, lamport_timestamp);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OperationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OperationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Operation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

}  // pub mod buffer

pub mod epoch {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum FileId {
  NONE = 0,
  BaseFileId = 1,
  NewFileId = 2,

}

const ENUM_MIN_FILE_ID: u8 = 0;
const ENUM_MAX_FILE_ID: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for FileId {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FileId {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FileId;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FileId;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FileId {
    type Output = FileId;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FileId>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_FILE_ID:[FileId; 3] = [
  FileId::NONE,
  FileId::BaseFileId,
  FileId::NewFileId
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_FILE_ID:[&'static str; 3] = [
    "NONE",
    "BaseFileId",
    "NewFileId"
];

pub fn enum_name_file_id(e: FileId) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_FILE_ID[index]
}

pub struct FileIdUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum FileType {
  Directory = 0,
  Text = 1,

}

const ENUM_MIN_FILE_TYPE: i8 = 0;
const ENUM_MAX_FILE_TYPE: i8 = 1;

impl<'a> flatbuffers::Follow<'a> for FileType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FileType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const FileType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const FileType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FileType {
    type Output = FileType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FileType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_FILE_TYPE:[FileType; 2] = [
  FileType::Directory,
  FileType::Text
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_FILE_TYPE:[&'static str; 2] = [
    "Directory",
    "Text"
];

pub fn enum_name_file_type(e: FileType) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_FILE_TYPE[index]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Operation {
  NONE = 0,
  InsertMetadata = 1,
  UpdateParent = 2,
  EditText = 3,

}

const ENUM_MIN_OPERATION: u8 = 0;
const ENUM_MAX_OPERATION: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for Operation {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Operation {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Operation;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Operation;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Operation {
    type Output = Operation;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Operation>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_OPERATION:[Operation; 4] = [
  Operation::NONE,
  Operation::InsertMetadata,
  Operation::UpdateParent,
  Operation::EditText
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_OPERATION:[&'static str; 4] = [
    "NONE",
    "InsertMetadata",
    "UpdateParent",
    "EditText"
];

pub fn enum_name_operation(e: Operation) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_OPERATION[index]
}

pub struct OperationUnionTableOffset {}
pub enum BaseFileIdOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BaseFileId<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BaseFileId<'a> {
    type Inner = BaseFileId<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BaseFileId<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BaseFileId {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BaseFileIdArgs) -> flatbuffers::WIPOffset<BaseFileId<'bldr>> {
      let mut builder = BaseFileIdBuilder::new(_fbb);
      builder.add_index(args.index);
      builder.finish()
    }

    pub const VT_INDEX: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn index(&self) -> u64 {
    self._tab.get::<u64>(BaseFileId::VT_INDEX, Some(0)).unwrap()
  }
}

pub struct BaseFileIdArgs {
    pub index: u64,
}
impl<'a> Default for BaseFileIdArgs {
    #[inline]
    fn default() -> Self {
        BaseFileIdArgs {
            index: 0,
        }
    }
}
pub struct BaseFileIdBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BaseFileIdBuilder<'a, 'b> {
  #[inline]
  pub fn add_index(&mut self, index: u64) {
    self.fbb_.push_slot::<u64>(BaseFileId::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BaseFileIdBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BaseFileIdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BaseFileId<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum NewFileIdOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct NewFileId<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NewFileId<'a> {
    type Inner = NewFileId<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> NewFileId<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        NewFileId {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args NewFileIdArgs<'args>) -> flatbuffers::WIPOffset<NewFileId<'bldr>> {
      let mut builder = NewFileIdBuilder::new(_fbb);
      if let Some(x) = args.id { builder.add_id(x); }
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn id(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(NewFileId::VT_ID, None)
  }
}

pub struct NewFileIdArgs<'a> {
    pub id: Option<&'a  super::Timestamp>,
}
impl<'a> Default for NewFileIdArgs<'a> {
    #[inline]
    fn default() -> Self {
        NewFileIdArgs {
            id: None,
        }
    }
}
pub struct NewFileIdBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NewFileIdBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(NewFileId::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NewFileIdBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NewFileIdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NewFileId<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum InsertMetadataOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InsertMetadata<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InsertMetadata<'a> {
    type Inner = InsertMetadata<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InsertMetadata<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InsertMetadata {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InsertMetadataArgs<'args>) -> flatbuffers::WIPOffset<InsertMetadata<'bldr>> {
      let mut builder = InsertMetadataBuilder::new(_fbb);
      if let Some(x) = args.lamport_timestamp { builder.add_lamport_timestamp(x); }
      if let Some(x) = args.local_timestamp { builder.add_local_timestamp(x); }
      if let Some(x) = args.name_in_parent { builder.add_name_in_parent(x); }
      if let Some(x) = args.parent_id { builder.add_parent_id(x); }
      if let Some(x) = args.file_id { builder.add_file_id(x); }
      builder.add_parent_id_type(args.parent_id_type);
      builder.add_file_type(args.file_type);
      builder.add_file_id_type(args.file_id_type);
      builder.finish()
    }

    pub const VT_FILE_ID_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_FILE_ID: flatbuffers::VOffsetT = 6;
    pub const VT_FILE_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_PARENT_ID_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_PARENT_ID: flatbuffers::VOffsetT = 12;
    pub const VT_NAME_IN_PARENT: flatbuffers::VOffsetT = 14;
    pub const VT_LOCAL_TIMESTAMP: flatbuffers::VOffsetT = 16;
    pub const VT_LAMPORT_TIMESTAMP: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn file_id_type(&self) -> FileId {
    self._tab.get::<FileId>(InsertMetadata::VT_FILE_ID_TYPE, Some(FileId::NONE)).unwrap()
  }
  #[inline]
  pub fn file_id(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(InsertMetadata::VT_FILE_ID, None)
  }
  #[inline]
  pub fn file_type(&self) -> FileType {
    self._tab.get::<FileType>(InsertMetadata::VT_FILE_TYPE, Some(FileType::Directory)).unwrap()
  }
  #[inline]
  pub fn parent_id_type(&self) -> FileId {
    self._tab.get::<FileId>(InsertMetadata::VT_PARENT_ID_TYPE, Some(FileId::NONE)).unwrap()
  }
  #[inline]
  pub fn parent_id(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(InsertMetadata::VT_PARENT_ID, None)
  }
  #[inline]
  pub fn name_in_parent(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(InsertMetadata::VT_NAME_IN_PARENT, None)
  }
  #[inline]
  pub fn local_timestamp(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(InsertMetadata::VT_LOCAL_TIMESTAMP, None)
  }
  #[inline]
  pub fn lamport_timestamp(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(InsertMetadata::VT_LAMPORT_TIMESTAMP, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn file_id_as_base_file_id(&'a self) -> Option<BaseFileId> {
    if self.file_id_type() == FileId::BaseFileId {
      self.file_id().map(|u| BaseFileId::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn file_id_as_new_file_id(&'a self) -> Option<NewFileId> {
    if self.file_id_type() == FileId::NewFileId {
      self.file_id().map(|u| NewFileId::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parent_id_as_base_file_id(&'a self) -> Option<BaseFileId> {
    if self.parent_id_type() == FileId::BaseFileId {
      self.parent_id().map(|u| BaseFileId::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parent_id_as_new_file_id(&'a self) -> Option<NewFileId> {
    if self.parent_id_type() == FileId::NewFileId {
      self.parent_id().map(|u| NewFileId::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct InsertMetadataArgs<'a> {
    pub file_id_type: FileId,
    pub file_id: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub file_type: FileType,
    pub parent_id_type: FileId,
    pub parent_id: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub name_in_parent: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub local_timestamp: Option<&'a  super::Timestamp>,
    pub lamport_timestamp: Option<&'a  super::Timestamp>,
}
impl<'a> Default for InsertMetadataArgs<'a> {
    #[inline]
    fn default() -> Self {
        InsertMetadataArgs {
            file_id_type: FileId::NONE,
            file_id: None,
            file_type: FileType::Directory,
            parent_id_type: FileId::NONE,
            parent_id: None,
            name_in_parent: None,
            local_timestamp: None,
            lamport_timestamp: None,
        }
    }
}
pub struct InsertMetadataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InsertMetadataBuilder<'a, 'b> {
  #[inline]
  pub fn add_file_id_type(&mut self, file_id_type: FileId) {
    self.fbb_.push_slot::<FileId>(InsertMetadata::VT_FILE_ID_TYPE, file_id_type, FileId::NONE);
  }
  #[inline]
  pub fn add_file_id(&mut self, file_id: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InsertMetadata::VT_FILE_ID, file_id);
  }
  #[inline]
  pub fn add_file_type(&mut self, file_type: FileType) {
    self.fbb_.push_slot::<FileType>(InsertMetadata::VT_FILE_TYPE, file_type, FileType::Directory);
  }
  #[inline]
  pub fn add_parent_id_type(&mut self, parent_id_type: FileId) {
    self.fbb_.push_slot::<FileId>(InsertMetadata::VT_PARENT_ID_TYPE, parent_id_type, FileId::NONE);
  }
  #[inline]
  pub fn add_parent_id(&mut self, parent_id: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InsertMetadata::VT_PARENT_ID, parent_id);
  }
  #[inline]
  pub fn add_name_in_parent(&mut self, name_in_parent: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InsertMetadata::VT_NAME_IN_PARENT, name_in_parent);
  }
  #[inline]
  pub fn add_local_timestamp(&mut self, local_timestamp: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(InsertMetadata::VT_LOCAL_TIMESTAMP, local_timestamp);
  }
  #[inline]
  pub fn add_lamport_timestamp(&mut self, lamport_timestamp: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(InsertMetadata::VT_LAMPORT_TIMESTAMP, lamport_timestamp);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InsertMetadataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InsertMetadataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InsertMetadata<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum UpdateParentOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct UpdateParent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UpdateParent<'a> {
    type Inner = UpdateParent<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> UpdateParent<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UpdateParent {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UpdateParentArgs<'args>) -> flatbuffers::WIPOffset<UpdateParent<'bldr>> {
      let mut builder = UpdateParentBuilder::new(_fbb);
      if let Some(x) = args.lamport_timestamp { builder.add_lamport_timestamp(x); }
      if let Some(x) = args.local_timestamp { builder.add_local_timestamp(x); }
      if let Some(x) = args.new_name_in_parent { builder.add_new_name_in_parent(x); }
      if let Some(x) = args.new_parent_id { builder.add_new_parent_id(x); }
      if let Some(x) = args.child_id { builder.add_child_id(x); }
      builder.add_new_parent_id_type(args.new_parent_id_type);
      builder.add_child_id_type(args.child_id_type);
      builder.finish()
    }

    pub const VT_CHILD_ID_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_CHILD_ID: flatbuffers::VOffsetT = 6;
    pub const VT_NEW_PARENT_ID_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_NEW_PARENT_ID: flatbuffers::VOffsetT = 10;
    pub const VT_NEW_NAME_IN_PARENT: flatbuffers::VOffsetT = 12;
    pub const VT_LOCAL_TIMESTAMP: flatbuffers::VOffsetT = 14;
    pub const VT_LAMPORT_TIMESTAMP: flatbuffers::VOffsetT = 16;

  #[inline]
  pub fn child_id_type(&self) -> FileId {
    self._tab.get::<FileId>(UpdateParent::VT_CHILD_ID_TYPE, Some(FileId::NONE)).unwrap()
  }
  #[inline]
  pub fn child_id(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(UpdateParent::VT_CHILD_ID, None)
  }
  #[inline]
  pub fn new_parent_id_type(&self) -> FileId {
    self._tab.get::<FileId>(UpdateParent::VT_NEW_PARENT_ID_TYPE, Some(FileId::NONE)).unwrap()
  }
  #[inline]
  pub fn new_parent_id(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(UpdateParent::VT_NEW_PARENT_ID, None)
  }
  #[inline]
  pub fn new_name_in_parent(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UpdateParent::VT_NEW_NAME_IN_PARENT, None)
  }
  #[inline]
  pub fn local_timestamp(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(UpdateParent::VT_LOCAL_TIMESTAMP, None)
  }
  #[inline]
  pub fn lamport_timestamp(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(UpdateParent::VT_LAMPORT_TIMESTAMP, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn child_id_as_base_file_id(&'a self) -> Option<BaseFileId> {
    if self.child_id_type() == FileId::BaseFileId {
      self.child_id().map(|u| BaseFileId::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn child_id_as_new_file_id(&'a self) -> Option<NewFileId> {
    if self.child_id_type() == FileId::NewFileId {
      self.child_id().map(|u| NewFileId::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_parent_id_as_base_file_id(&'a self) -> Option<BaseFileId> {
    if self.new_parent_id_type() == FileId::BaseFileId {
      self.new_parent_id().map(|u| BaseFileId::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_parent_id_as_new_file_id(&'a self) -> Option<NewFileId> {
    if self.new_parent_id_type() == FileId::NewFileId {
      self.new_parent_id().map(|u| NewFileId::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct UpdateParentArgs<'a> {
    pub child_id_type: FileId,
    pub child_id: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub new_parent_id_type: FileId,
    pub new_parent_id: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub new_name_in_parent: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub local_timestamp: Option<&'a  super::Timestamp>,
    pub lamport_timestamp: Option<&'a  super::Timestamp>,
}
impl<'a> Default for UpdateParentArgs<'a> {
    #[inline]
    fn default() -> Self {
        UpdateParentArgs {
            child_id_type: FileId::NONE,
            child_id: None,
            new_parent_id_type: FileId::NONE,
            new_parent_id: None,
            new_name_in_parent: None,
            local_timestamp: None,
            lamport_timestamp: None,
        }
    }
}
pub struct UpdateParentBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UpdateParentBuilder<'a, 'b> {
  #[inline]
  pub fn add_child_id_type(&mut self, child_id_type: FileId) {
    self.fbb_.push_slot::<FileId>(UpdateParent::VT_CHILD_ID_TYPE, child_id_type, FileId::NONE);
  }
  #[inline]
  pub fn add_child_id(&mut self, child_id: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateParent::VT_CHILD_ID, child_id);
  }
  #[inline]
  pub fn add_new_parent_id_type(&mut self, new_parent_id_type: FileId) {
    self.fbb_.push_slot::<FileId>(UpdateParent::VT_NEW_PARENT_ID_TYPE, new_parent_id_type, FileId::NONE);
  }
  #[inline]
  pub fn add_new_parent_id(&mut self, new_parent_id: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateParent::VT_NEW_PARENT_ID, new_parent_id);
  }
  #[inline]
  pub fn add_new_name_in_parent(&mut self, new_name_in_parent: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateParent::VT_NEW_NAME_IN_PARENT, new_name_in_parent);
  }
  #[inline]
  pub fn add_local_timestamp(&mut self, local_timestamp: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(UpdateParent::VT_LOCAL_TIMESTAMP, local_timestamp);
  }
  #[inline]
  pub fn add_lamport_timestamp(&mut self, lamport_timestamp: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(UpdateParent::VT_LAMPORT_TIMESTAMP, lamport_timestamp);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UpdateParentBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UpdateParentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UpdateParent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum EditTextOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct EditText<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EditText<'a> {
    type Inner = EditText<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> EditText<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EditText {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EditTextArgs<'args>) -> flatbuffers::WIPOffset<EditText<'bldr>> {
      let mut builder = EditTextBuilder::new(_fbb);
      if let Some(x) = args.lamport_timestamp { builder.add_lamport_timestamp(x); }
      if let Some(x) = args.local_timestamp { builder.add_local_timestamp(x); }
      if let Some(x) = args.edits { builder.add_edits(x); }
      if let Some(x) = args.file_id { builder.add_file_id(x); }
      builder.add_file_id_type(args.file_id_type);
      builder.finish()
    }

    pub const VT_FILE_ID_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_FILE_ID: flatbuffers::VOffsetT = 6;
    pub const VT_EDITS: flatbuffers::VOffsetT = 8;
    pub const VT_LOCAL_TIMESTAMP: flatbuffers::VOffsetT = 10;
    pub const VT_LAMPORT_TIMESTAMP: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn file_id_type(&self) -> FileId {
    self._tab.get::<FileId>(EditText::VT_FILE_ID_TYPE, Some(FileId::NONE)).unwrap()
  }
  #[inline]
  pub fn file_id(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(EditText::VT_FILE_ID, None)
  }
  #[inline]
  pub fn edits(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<super::buffer::Operation<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<super::buffer::Operation<'a>>>>>(EditText::VT_EDITS, None)
  }
  #[inline]
  pub fn local_timestamp(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(EditText::VT_LOCAL_TIMESTAMP, None)
  }
  #[inline]
  pub fn lamport_timestamp(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(EditText::VT_LAMPORT_TIMESTAMP, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn file_id_as_base_file_id(&'a self) -> Option<BaseFileId> {
    if self.file_id_type() == FileId::BaseFileId {
      self.file_id().map(|u| BaseFileId::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn file_id_as_new_file_id(&'a self) -> Option<NewFileId> {
    if self.file_id_type() == FileId::NewFileId {
      self.file_id().map(|u| NewFileId::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct EditTextArgs<'a> {
    pub file_id_type: FileId,
    pub file_id: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub edits: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<super::buffer::Operation<'a >>>>>,
    pub local_timestamp: Option<&'a  super::Timestamp>,
    pub lamport_timestamp: Option<&'a  super::Timestamp>,
}
impl<'a> Default for EditTextArgs<'a> {
    #[inline]
    fn default() -> Self {
        EditTextArgs {
            file_id_type: FileId::NONE,
            file_id: None,
            edits: None,
            local_timestamp: None,
            lamport_timestamp: None,
        }
    }
}
pub struct EditTextBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EditTextBuilder<'a, 'b> {
  #[inline]
  pub fn add_file_id_type(&mut self, file_id_type: FileId) {
    self.fbb_.push_slot::<FileId>(EditText::VT_FILE_ID_TYPE, file_id_type, FileId::NONE);
  }
  #[inline]
  pub fn add_file_id(&mut self, file_id: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EditText::VT_FILE_ID, file_id);
  }
  #[inline]
  pub fn add_edits(&mut self, edits: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<super::buffer::Operation<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EditText::VT_EDITS, edits);
  }
  #[inline]
  pub fn add_local_timestamp(&mut self, local_timestamp: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(EditText::VT_LOCAL_TIMESTAMP, local_timestamp);
  }
  #[inline]
  pub fn add_lamport_timestamp(&mut self, lamport_timestamp: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(EditText::VT_LAMPORT_TIMESTAMP, lamport_timestamp);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EditTextBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EditTextBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EditText<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

}  // pub mod epoch

pub mod worktree {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Operation {
  NONE = 0,
  StartEpoch = 1,
  EpochOperation = 2,

}

const ENUM_MIN_OPERATION: u8 = 0;
const ENUM_MAX_OPERATION: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for Operation {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Operation {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Operation;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Operation;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Operation {
    type Output = Operation;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Operation>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_OPERATION:[Operation; 3] = [
  Operation::NONE,
  Operation::StartEpoch,
  Operation::EpochOperation
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_OPERATION:[&'static str; 3] = [
    "NONE",
    "StartEpoch",
    "EpochOperation"
];

pub fn enum_name_operation(e: Operation) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_OPERATION[index]
}

pub struct OperationUnionTableOffset {}
pub enum StartEpochOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StartEpoch<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StartEpoch<'a> {
    type Inner = StartEpoch<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StartEpoch<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StartEpoch {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StartEpochArgs<'args>) -> flatbuffers::WIPOffset<StartEpoch<'bldr>> {
      let mut builder = StartEpochBuilder::new(_fbb);
      if let Some(x) = args.head { builder.add_head(x); }
      if let Some(x) = args.epoch_id { builder.add_epoch_id(x); }
      builder.finish()
    }

    pub const VT_EPOCH_ID: flatbuffers::VOffsetT = 4;
    pub const VT_HEAD: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn epoch_id(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(StartEpoch::VT_EPOCH_ID, None)
  }
  #[inline]
  pub fn head(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(StartEpoch::VT_HEAD, None).map(|v| v.safe_slice())
  }
}

pub struct StartEpochArgs<'a> {
    pub epoch_id: Option<&'a  super::Timestamp>,
    pub head: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for StartEpochArgs<'a> {
    #[inline]
    fn default() -> Self {
        StartEpochArgs {
            epoch_id: None,
            head: None,
        }
    }
}
pub struct StartEpochBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StartEpochBuilder<'a, 'b> {
  #[inline]
  pub fn add_epoch_id(&mut self, epoch_id: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(StartEpoch::VT_EPOCH_ID, epoch_id);
  }
  #[inline]
  pub fn add_head(&mut self, head: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StartEpoch::VT_HEAD, head);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StartEpochBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StartEpochBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StartEpoch<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum EpochOperationOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct EpochOperation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EpochOperation<'a> {
    type Inner = EpochOperation<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> EpochOperation<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EpochOperation {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EpochOperationArgs<'args>) -> flatbuffers::WIPOffset<EpochOperation<'bldr>> {
      let mut builder = EpochOperationBuilder::new(_fbb);
      if let Some(x) = args.operation { builder.add_operation(x); }
      if let Some(x) = args.epoch_id { builder.add_epoch_id(x); }
      builder.add_operation_type(args.operation_type);
      builder.finish()
    }

    pub const VT_EPOCH_ID: flatbuffers::VOffsetT = 4;
    pub const VT_OPERATION_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_OPERATION: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn epoch_id(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(EpochOperation::VT_EPOCH_ID, None)
  }
  #[inline]
  pub fn operation_type(&self) -> super::epoch::Operation {
    self._tab.get::<super::epoch::Operation>(EpochOperation::VT_OPERATION_TYPE, Some(super::epoch::Operation::NONE)).unwrap()
  }
  #[inline]
  pub fn operation(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(EpochOperation::VT_OPERATION, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn operation_as_insert_metadata(&'a self) -> Option<super::epoch::InsertMetadata> {
    if self.operation_type() == super::epoch::Operation::InsertMetadata {
      self.operation().map(|u| super::epoch::InsertMetadata::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn operation_as_update_parent(&'a self) -> Option<super::epoch::UpdateParent> {
    if self.operation_type() == super::epoch::Operation::UpdateParent {
      self.operation().map(|u| super::epoch::UpdateParent::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn operation_as_edit_text(&'a self) -> Option<super::epoch::EditText> {
    if self.operation_type() == super::epoch::Operation::EditText {
      self.operation().map(|u| super::epoch::EditText::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct EpochOperationArgs<'a> {
    pub epoch_id: Option<&'a  super::Timestamp>,
    pub operation_type: super::epoch::Operation,
    pub operation: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for EpochOperationArgs<'a> {
    #[inline]
    fn default() -> Self {
        EpochOperationArgs {
            epoch_id: None,
            operation_type: super::epoch::Operation::NONE,
            operation: None,
        }
    }
}
pub struct EpochOperationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EpochOperationBuilder<'a, 'b> {
  #[inline]
  pub fn add_epoch_id(&mut self, epoch_id: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(EpochOperation::VT_EPOCH_ID, epoch_id);
  }
  #[inline]
  pub fn add_operation_type(&mut self, operation_type: super::epoch::Operation) {
    self.fbb_.push_slot::<super::epoch::Operation>(EpochOperation::VT_OPERATION_TYPE, operation_type, super::epoch::Operation::NONE);
  }
  #[inline]
  pub fn add_operation(&mut self, operation: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EpochOperation::VT_OPERATION, operation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EpochOperationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EpochOperationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EpochOperation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum OperationEnvelopeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct OperationEnvelope<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OperationEnvelope<'a> {
    type Inner = OperationEnvelope<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> OperationEnvelope<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OperationEnvelope {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OperationEnvelopeArgs) -> flatbuffers::WIPOffset<OperationEnvelope<'bldr>> {
      let mut builder = OperationEnvelopeBuilder::new(_fbb);
      if let Some(x) = args.operation { builder.add_operation(x); }
      builder.add_operation_type(args.operation_type);
      builder.finish()
    }

    pub const VT_OPERATION_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_OPERATION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn operation_type(&self) -> Operation {
    self._tab.get::<Operation>(OperationEnvelope::VT_OPERATION_TYPE, Some(Operation::NONE)).unwrap()
  }
  #[inline]
  pub fn operation(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(OperationEnvelope::VT_OPERATION, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn operation_as_start_epoch(&'a self) -> Option<StartEpoch> {
    if self.operation_type() == Operation::StartEpoch {
      self.operation().map(|u| StartEpoch::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn operation_as_epoch_operation(&'a self) -> Option<EpochOperation> {
    if self.operation_type() == Operation::EpochOperation {
      self.operation().map(|u| EpochOperation::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct OperationEnvelopeArgs {
    pub operation_type: Operation,
    pub operation: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for OperationEnvelopeArgs {
    #[inline]
    fn default() -> Self {
        OperationEnvelopeArgs {
            operation_type: Operation::NONE,
            operation: None,
        }
    }
}
pub struct OperationEnvelopeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OperationEnvelopeBuilder<'a, 'b> {
  #[inline]
  pub fn add_operation_type(&mut self, operation_type: Operation) {
    self.fbb_.push_slot::<Operation>(OperationEnvelope::VT_OPERATION_TYPE, operation_type, Operation::NONE);
  }
  #[inline]
  pub fn add_operation(&mut self, operation: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OperationEnvelope::VT_OPERATION, operation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OperationEnvelopeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OperationEnvelopeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OperationEnvelope<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

}  // pub mod worktree

use flatbuffers::EndianScalar;
